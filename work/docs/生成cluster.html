<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.1.1 (456663)"/><meta name="author" content="a798987859@126.com"/><meta name="created" content="2018-05-29 13:00:47 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-05-29 13:25:42 +0000"/><title>生成cluster</title></head><body><div>对于每条未被生成到cluster_node里的商品匹配对：</div><div><br/></div><div>拆成两个商品</div><div>c_item,b_item</div><div><br/></div><div>每个商品含有的信息包括</div><div><br/></div><div>产品ID</div><div>系统ID</div><div>platform</div><div>类别名</div><div><br/></div><div>下面是处理逻辑</div><hr/><div><br/></div><div>假设这对商品分别是b_id_1 : c_id_4</div><div>先判断这条匹配关系是否已经cluster_edge表里，如果在，标记已处理并返回。</div><div><br/></div><div>如果不在：</div><div>（整个是一个事务）</div><div><br/></div><div>先插入匹配关系到cluster_edge中去，为了方便起见，正反差两条，比如{from:b_id_1,to:c_id_4},{from:c_id_4,to:b_id_1}</div><div><br/></div><div><br/></div><div>然后 从cluster_node表里查询两个item的cluster_id,假设分别为b_id_1_cluster_id,c_id_4_cluster_id</div><div><br/></div><div>如果两个都是空：</div><div><span>    新的cluster，生成新的cluster（）</span><br/></div><div>如果其中一个是空（假设b_id_1_cluster_id），另一个不是空（假设c_id_4_cluster_id）：</div><div><span>    插入是空的item，cluster_id设置为不是空的那个值，即把b_item归属到c_item所在的cluster里。</span><br/></div><div><span><span>    按照顺序给b_item生成全局递增序列号并赋值，</span><br/></span></div><div><span><span><span>    把c_id_4_cluster_id ，即c_item的cluster_id,赋值给b_item</span><br/></span></span></div><div><span><span><span><span>    插入b_item</span><br/></span></span></span></div><div>如果两个都不是空，且不相等：</div><div><span>    合并两个cluster（）</span><br/></div><div><span><br/></span></div><div><span><br/></span></div><hr/><div>子函数逻辑：</div><div>生成新的cluster（）：</div><div><span>    给这两个item生成一个全局（整个系统）唯一且递增的序列号，分别设为b_seq_num,c_seq_num</span><br/></div><div><span><span>    cluster_id 设置为b_seq_num,c_seq_num里比较小的那个值。</span><br/></span></div><div><span><span><span>    给b_item,c_item赋值</span><br/></span></span></div><div><span><span><span><span>    分别插入cluster_node表</span><br/></span></span></span></div><div><span><span><span><span><br/></span></span></span></span></div><div>合并两个cluster（）:</div><div><span>    把两个cluster_id中较大的cluster，对应的所有商品的cluster_id设置为设置为较小的那个cluster_id</span><br/></div><div><span><br/></span></div><div><span><br/></span></div><hr/><div>关键点在每个商品有一个稳定的全局递增序列号，通过这个序列号来维护整个cluster_id的稳定性。</div><div><br/></div><div>后续所有流程里，cluster_id将是整个系统的核心，是最终商品的统一id。</div><div><br/></div><div>一个非常重要的规则：<b>cluster_id的设置规则是同一个cluster里所有匹配商品的最小的序列号。</b></div><div><br/></div><div>举个例子：</div><div>现在有a，b，c，d，e三个商品，序列号分别为1，2，3，4，5</div><div><br/></div><div>本来a，b，c是一个cluster，cluster_id为1；</div><div>d，e是一个cluster,cluster_id为4；</div><div><br/></div><div>这时发现a，d是匹配的，那么就要执行上面第三种逻辑，合并两个cluster</div><div>a，b，c，d，e成为一个cluster,cluster_id为1。</div><div><br/></div><div><br/></div><div>后来又过了一段时间，人工审核发现a，d不匹配，需要拆开两个cluster</div><div>删除a，d匹配边，这时候重新生成两个cluster，那么按照规则<span style="font-weight: bold;">cluster_id的设置规则是同一个cluster里所有匹配商品的最小的序列号</span></div><div>系统最重的两个cluster_id及商品和初始状态一致。</div><div><br/></div><div>即这个cluster_id的赋值规则能够最大程度保障cluster_id的稳定性。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>